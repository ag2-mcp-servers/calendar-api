# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:06:09+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Path, Query
from pydantic import conint

from models import (
    Acl,
    AclRule,
    Alt,
    Calendar,
    CalendarList,
    CalendarListEntry,
    Channel,
    Colors,
    Event,
    Events,
    EventTypes,
    FreeBusyRequest,
    FreeBusyResponse,
    MinAccessRole,
    OrderBy,
    PrivateExtendedProperty,
    SendUpdates,
    Setting,
    Settings,
    SharedExtendedProperty,
)

app = MCPProxy(
    contact={'name': 'Google', 'url': 'https://google.com', 'x-twitter': 'youtube'},
    description='Manipulates events and other calendar data.',
    license={
        'name': 'Creative Commons Attribution 3.0',
        'url': 'http://creativecommons.org/licenses/by/3.0/',
    },
    termsOfService='https://developers.google.com/terms/',
    title='Calendar API',
    version='v3',
    servers=[{'url': 'https://www.googleapis.com/calendar/v3'}],
)


@app.post(
    '/calendars',
    description=""" Creates a secondary calendar. """,
    tags=['calendar_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendars_insert(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Calendar = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/calendars/{calendarId}',
    description=""" Deletes a secondary calendar. Use calendars.clear for clearing all events on primary calendars. """,
    tags=['calendar_management', 'calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendars_delete(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendars/{calendarId}',
    description=""" Returns metadata for a calendar. """,
    tags=['calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendars_get(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/calendars/{calendarId}',
    description=""" Updates metadata for a calendar. This method supports patch semantics. """,
    tags=['calendar_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendars_patch(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Calendar = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/calendars/{calendarId}',
    description=""" Updates metadata for a calendar. """,
    tags=['calendar_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendars_update(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Calendar = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendars/{calendarId}/acl',
    description=""" Returns the rules in the access control list for the calendar. """,
    tags=['calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_list(
    calendar_id: str = Path(..., alias='calendarId'),
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/acl',
    description=""" Creates an access control rule. """,
    tags=['calendar_acl_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_insert(
    calendar_id: str = Path(..., alias='calendarId'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: AclRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/acl/watch',
    description=""" Watch for changes to ACL resources. """,
    tags=['calendar_notification_channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_watch(
    calendar_id: str = Path(..., alias='calendarId'),
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/calendars/{calendarId}/acl/{ruleId}',
    description=""" Deletes an access control rule. """,
    tags=['calendar_acl_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_delete(
    calendar_id: str = Path(..., alias='calendarId'),
    rule_id: str = Path(..., alias='ruleId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendars/{calendarId}/acl/{ruleId}',
    description=""" Returns an access control rule. """,
    tags=['calendar_acl_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_get(
    calendar_id: str = Path(..., alias='calendarId'),
    rule_id: str = Path(..., alias='ruleId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/calendars/{calendarId}/acl/{ruleId}',
    description=""" Updates an access control rule. This method supports patch semantics. """,
    tags=['calendar_acl_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_patch(
    calendar_id: str = Path(..., alias='calendarId'),
    rule_id: str = Path(..., alias='ruleId'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: AclRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/calendars/{calendarId}/acl/{ruleId}',
    description=""" Updates an access control rule. """,
    tags=['calendar_acl_handling'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_acl_update(
    calendar_id: str = Path(..., alias='calendarId'),
    rule_id: str = Path(..., alias='ruleId'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: AclRule = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/clear',
    description=""" Clears a primary calendar. This operation deletes all events associated with the primary calendar of an account. """,
    tags=[
        'calendar_management',
        'calendar_acl_handling',
        'calendar_event_management',
        'calendar_list_operations',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendars_clear(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendars/{calendarId}/events',
    description=""" Returns events on the specified calendar. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_list(
    calendar_id: str = Path(..., alias='calendarId'),
    always_include_email: Optional[bool] = Query(None, alias='alwaysIncludeEmail'),
    event_types: Optional[EventTypes] = Query(None, alias='eventTypes'),
    i_cal_u_i_d: Optional[str] = Query(None, alias='iCalUID'),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    order_by: Optional[OrderBy] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    private_extended_property: Optional[PrivateExtendedProperty] = Query(
        None, alias='privateExtendedProperty'
    ),
    q: Optional[str] = None,
    shared_extended_property: Optional[SharedExtendedProperty] = Query(
        None, alias='sharedExtendedProperty'
    ),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    show_hidden_invitations: Optional[bool] = Query(
        None, alias='showHiddenInvitations'
    ),
    single_events: Optional[bool] = Query(None, alias='singleEvents'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    time_max: Optional[str] = Query(None, alias='timeMax'),
    time_min: Optional[str] = Query(None, alias='timeMin'),
    time_zone: Optional[str] = Query(None, alias='timeZone'),
    updated_min: Optional[str] = Query(None, alias='updatedMin'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/events',
    description=""" Creates an event. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_insert(
    calendar_id: str = Path(..., alias='calendarId'),
    conference_data_version: Optional[conint(ge=0, le=1)] = Query(
        None, alias='conferenceDataVersion'
    ),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    send_updates: Optional[SendUpdates] = Query(None, alias='sendUpdates'),
    supports_attachments: Optional[bool] = Query(None, alias='supportsAttachments'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Event = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/events/import',
    description=""" Imports an event. This operation is used to add a private copy of an existing event to a calendar. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_import(
    calendar_id: str = Path(..., alias='calendarId'),
    conference_data_version: Optional[conint(ge=0, le=1)] = Query(
        None, alias='conferenceDataVersion'
    ),
    supports_attachments: Optional[bool] = Query(None, alias='supportsAttachments'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Event = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/events/quickAdd',
    description=""" Creates an event based on a simple text string. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_quick_add(
    calendar_id: str = Path(..., alias='calendarId'),
    text: str = ...,
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    send_updates: Optional[SendUpdates] = Query(None, alias='sendUpdates'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/events/watch',
    description=""" Watch for changes to Events resources. """,
    tags=['calendar_event_management', 'calendar_notification_channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_watch(
    calendar_id: str = Path(..., alias='calendarId'),
    always_include_email: Optional[bool] = Query(None, alias='alwaysIncludeEmail'),
    event_types: Optional[EventTypes] = Query(None, alias='eventTypes'),
    i_cal_u_i_d: Optional[str] = Query(None, alias='iCalUID'),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    order_by: Optional[OrderBy] = Query(None, alias='orderBy'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    private_extended_property: Optional[PrivateExtendedProperty] = Query(
        None, alias='privateExtendedProperty'
    ),
    q: Optional[str] = None,
    shared_extended_property: Optional[SharedExtendedProperty] = Query(
        None, alias='sharedExtendedProperty'
    ),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    show_hidden_invitations: Optional[bool] = Query(
        None, alias='showHiddenInvitations'
    ),
    single_events: Optional[bool] = Query(None, alias='singleEvents'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    time_max: Optional[str] = Query(None, alias='timeMax'),
    time_min: Optional[str] = Query(None, alias='timeMin'),
    time_zone: Optional[str] = Query(None, alias='timeZone'),
    updated_min: Optional[str] = Query(None, alias='updatedMin'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/calendars/{calendarId}/events/{eventId}',
    description=""" Deletes an event. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_delete(
    calendar_id: str = Path(..., alias='calendarId'),
    event_id: str = Path(..., alias='eventId'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    send_updates: Optional[SendUpdates] = Query(None, alias='sendUpdates'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendars/{calendarId}/events/{eventId}',
    description=""" Returns an event based on its Google Calendar ID. To retrieve an event using its iCalendar ID, call the events.list method using the iCalUID parameter. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_get(
    calendar_id: str = Path(..., alias='calendarId'),
    event_id: str = Path(..., alias='eventId'),
    always_include_email: Optional[bool] = Query(None, alias='alwaysIncludeEmail'),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    time_zone: Optional[str] = Query(None, alias='timeZone'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/calendars/{calendarId}/events/{eventId}',
    description=""" Updates an event. This method supports patch semantics. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_patch(
    calendar_id: str = Path(..., alias='calendarId'),
    event_id: str = Path(..., alias='eventId'),
    always_include_email: Optional[bool] = Query(None, alias='alwaysIncludeEmail'),
    conference_data_version: Optional[conint(ge=0, le=1)] = Query(
        None, alias='conferenceDataVersion'
    ),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    send_updates: Optional[SendUpdates] = Query(None, alias='sendUpdates'),
    supports_attachments: Optional[bool] = Query(None, alias='supportsAttachments'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Event = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/calendars/{calendarId}/events/{eventId}',
    description=""" Updates an event. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_update(
    calendar_id: str = Path(..., alias='calendarId'),
    event_id: str = Path(..., alias='eventId'),
    always_include_email: Optional[bool] = Query(None, alias='alwaysIncludeEmail'),
    conference_data_version: Optional[conint(ge=0, le=1)] = Query(
        None, alias='conferenceDataVersion'
    ),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    send_updates: Optional[SendUpdates] = Query(None, alias='sendUpdates'),
    supports_attachments: Optional[bool] = Query(None, alias='supportsAttachments'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Event = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calendars/{calendarId}/events/{eventId}/instances',
    description=""" Returns instances of the specified recurring event. """,
    tags=['calendar_event_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_instances(
    calendar_id: str = Path(..., alias='calendarId'),
    event_id: str = Path(..., alias='eventId'),
    always_include_email: Optional[bool] = Query(None, alias='alwaysIncludeEmail'),
    max_attendees: Optional[conint(ge=1)] = Query(None, alias='maxAttendees'),
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    original_start: Optional[str] = Query(None, alias='originalStart'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    time_max: Optional[str] = Query(None, alias='timeMax'),
    time_min: Optional[str] = Query(None, alias='timeMin'),
    time_zone: Optional[str] = Query(None, alias='timeZone'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calendars/{calendarId}/events/{eventId}/move',
    description=""" Moves an event to another calendar, i.e. changes an event's organizer. """,
    tags=['calendar_event_management', 'calendar_notification_channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_events_move(
    calendar_id: str = Path(..., alias='calendarId'),
    event_id: str = Path(..., alias='eventId'),
    destination: str = ...,
    send_notifications: Optional[bool] = Query(None, alias='sendNotifications'),
    send_updates: Optional[SendUpdates] = Query(None, alias='sendUpdates'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/channels/stop',
    description=""" Stop watching resources through this channel """,
    tags=['calendar_notification_channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_channels_stop(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/colors',
    description=""" Returns the color definitions for calendars and events. """,
    tags=[
        'calendar_management',
        'calendar_acl_handling',
        'calendar_event_management',
        'calendar_recurring_event_instances',
        'calendar_availability_queries',
        'calendar_color_set_operations',
        'calendar_notification_channel_management',
        'calendar_list_operations',
        'calendar_settings_management',
    ],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_colors_get(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/freeBusy',
    description=""" Returns free/busy information for a set of calendars. """,
    tags=['calendar_availability_queries'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_freebusy_query(
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: FreeBusyRequest = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/me/calendarList',
    description=""" Returns the calendars on the user's calendar list. """,
    tags=['calendar_acl_handling', 'calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_list(
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    min_access_role: Optional[MinAccessRole] = Query(None, alias='minAccessRole'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    show_hidden: Optional[bool] = Query(None, alias='showHidden'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users/me/calendarList',
    description=""" Inserts an existing calendar into the user's calendar list. """,
    tags=['calendar_list_operations', 'calendar_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_insert(
    color_rgb_format: Optional[bool] = Query(None, alias='colorRgbFormat'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: CalendarListEntry = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users/me/calendarList/watch',
    description=""" Watch for changes to CalendarList resources. """,
    tags=['calendar_notification_channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_watch(
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    min_access_role: Optional[MinAccessRole] = Query(None, alias='minAccessRole'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    show_deleted: Optional[bool] = Query(None, alias='showDeleted'),
    show_hidden: Optional[bool] = Query(None, alias='showHidden'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/users/me/calendarList/{calendarId}',
    description=""" Removes a calendar from the user's calendar list. """,
    tags=['calendar_management', 'calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_delete(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/me/calendarList/{calendarId}',
    description=""" Returns a calendar from the user's calendar list. """,
    tags=['calendar_management', 'calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_get(
    calendar_id: str = Path(..., alias='calendarId'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/users/me/calendarList/{calendarId}',
    description=""" Updates an existing calendar on the user's calendar list. This method supports patch semantics. """,
    tags=['calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_patch(
    calendar_id: str = Path(..., alias='calendarId'),
    color_rgb_format: Optional[bool] = Query(None, alias='colorRgbFormat'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: CalendarListEntry = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/users/me/calendarList/{calendarId}',
    description=""" Updates an existing calendar on the user's calendar list. """,
    tags=['calendar_list_operations', 'calendar_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_calendar_list_update(
    calendar_id: str = Path(..., alias='calendarId'),
    color_rgb_format: Optional[bool] = Query(None, alias='colorRgbFormat'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: CalendarListEntry = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/me/settings',
    description=""" Returns all user settings for the authenticated user. """,
    tags=['calendar_list_operations'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_settings_list(
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users/me/settings/watch',
    description=""" Watch for changes to Settings resources. """,
    tags=['calendar_notification_channel_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_settings_watch(
    max_results: Optional[conint(ge=1)] = Query(None, alias='maxResults'),
    page_token: Optional[str] = Query(None, alias='pageToken'),
    sync_token: Optional[str] = Query(None, alias='syncToken'),
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
    body: Channel = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/me/settings/{setting}',
    description=""" Returns a single user setting. """,
    tags=['calendar_settings_management'],
    security=[
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
        UnsuportedSecurityStub(name="None"),
    ],
)
def calendar_settings_get(
    setting: str,
    alt: Optional[Alt] = None,
    fields: Optional[str] = None,
    key: Optional[str] = None,
    oauth_token: Optional[str] = None,
    pretty_print: Optional[bool] = Query(None, alias='prettyPrint'),
    quota_user: Optional[str] = Query(None, alias='quotaUser'),
    user_ip: Optional[str] = Query(None, alias='userIp'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
